master node
kube-apiserver: exposes Kubernetes API used by client, along with CLI tools and components to interact with cluster.
Validates and configures data for API objects i.e. pods, services, replication controllers
etcd: consistent highly available keystore, used as Kubernetes' backing store for all cluster data
kube-scheduler: responsible for distributing work or containers across multiple nodes. Reads pod requirements and schedules them based on resource availability.
worker node
kubelet: agent that runs on each node to monitor assigned pods and ensure that containers described in pods are healthy and running
kube-proxy: network proxy and load balancer for Kubernetes and services on each worker node. Helps make services available to external parties.

Requires network to communicate between architecture components. 
Includes pod network for communication between pods across clusters.
Includes service network for communication between pods amd Kubernetes services.
Includes external network to allow external access from/to Kubernetes services.

Kubernetes supports persistent storage for containerized applications to access storage volumes independent from container lifecycle
Volumes: API object representing storage mounted into containers
Persistent volumes (PVs): long-lived storage initialized by an administrator
Persistent volume claims (PVCs): the requests that users make for storage

Extensibility and customization:
Custom resources: extends the Kubernetes API to support objects
Operators: has all application-specific controllers to manage custom resources
Admission controllers: intercepts requests to enforce custom requirements
Service catalog: provisions cloud services from external brokers

Fundamental API resources
Pod: represents a group of one or more containers and resources to run an application. Containers in a pod share an IP address, IPC (inter-process commnications),
hostname and other resources. Pods abstract the underlying infrastructure complexities.
Service: K8s service provides a consistent endpoint which has already been named. Used to access a group of pods. K8s services  enable loose coupling between
between dependent pods and provide load balancing across pods. Service group pods provide policies to access them.
Volumes: a K8s volume enables data to survive container restarts and upgrades via attached storage. Pod volumes outlive the executable container and facilitate
data sharing between containers that are running as pods
Namespaces: k8s supports multiple virtual clusters backed by same physical cluster via namespaces. Namespaces partition the cluster resources between multiple
users and provide isolation between teams and applications. Resource quotas can be applied per namespace.
https://www.cncf.io/blog/2019/08/19/how-kubernetes-works/

Kubernetes Controllers: k8s uses controller processes to regulate cluster state. Controllers manage pod instances removing need to do so manually. Examples:
ReplicaSet: ensures number of desired pod replicas 
Deployment: manages ReplicaSet to roll out new software versions

Labels: Key/value pairs attached to k8s objects like pods and services. Provide identifying attributes that can be used to group objects
Selectors: allow groupings based on labels during object creation, list and watch operations
Annotations: provide way to attach arbitrary non-identifying metadata on objects that can be retrieved
by tools and libraries. Annotations do not allow object grouping like labels and selectors do.
Horizontal Pod Autoscaler: automatically scales number of pods based on CPU utilization
ConfigMaps and Secrets: stores credentials and other sensitive data to keep them out of container images or application code 
Security Contexts: a pod security context applies privileges or acess control settings like Linux
capabilities across all containers in pod. Can be set at container level to override pod level
Network policies: secure pod networks with rules that control ingress/egress connectivity to allow k8s admins 
to enforce org security requirements
Deployments: k8s deployments provide declarative updates to applications. Desired application state
described in deployment resource which is asynchronously maintained by k8s. Provides robust rollouts/rollbacks
for software deployments.
Statefulsets: manage stateful apps like DBs that require stable/persistent storage with ordinal and unique
IDs for each replica. Safe to delete and reschedule pods managed by Statefulsets
DaemonSet: ensures that a pod runs on every node in cluster or selection of nodes. Nodes are automatically
added/removede as pods are automatically added/removed. Provide cluster services i.e. log collection, monitoring agents etc.
Job: creates one or more pods to run until successful termination. Facilitates moving batch processes
once they are completed in k8s clusters. Unlike long-running services via deployments, completion/fail 
counts of batch processes can be tracked
CronJobs: time based automation. Can set at k8s level instead of Cron at Linux OS level
Reconciliation model: instead of manual container/pod instance management, k8s implements controller
reconciliation approach to automation based on desired state declarations. Components i.e. ReplicaSets
and deployments will be monitored by running instances against specifications that drive towards desired state.

